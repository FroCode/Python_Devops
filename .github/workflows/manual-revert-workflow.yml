name: Revert Squash Merge Workflow
on:
  workflow_dispatch:
    inputs:
      branch_name:
        description: "Feature branch whose last squash merge into dev should be reverted (e.g., feature/30)"
        required: true
      conflict_resolution:
        description: "Resolution strategy for modify/delete conflicts: 'keep' (keep HEAD version) or 'delete' (accept deletion from revert)"
        required: false
        default: "keep"

jobs:
  revert-squash-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT }}

      - name: Normalize branch name
        id: normalize
        run: |
          BRANCH_NAME=$(echo "${{ github.event.inputs.branch_name }}" | sed 's#^remotes/origin/##')
          if [[ ! "$BRANCH_NAME" =~ ^[a-zA-Z0-9._/-]+$ ]]; then
            echo "Error: Invalid branch name '$BRANCH_NAME'"
            exit 1
          fi
          echo "normalized_branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Switch to dev
        run: |
          git fetch origin dev
          git checkout dev
          git pull origin dev

      - name: Find latest squash merge commit
        id: find_commit
        run: |
          PATTERN="${{ steps.normalize.outputs.normalized_branch }}"
          COMMIT=$(git log dev --grep="from .*$PATTERN" --pretty=%H -n 1)
          if [ -z "$COMMIT" ]; then
            echo "Error: No squash merge commit found in dev for '$PATTERN'"
            exit 1
          fi
          echo "commit_sha=$COMMIT" >> $GITHUB_OUTPUT

      - name: Check if commit already reverted
        id: check_revert
        run: |
          COMMIT="${{ steps.find_commit.outputs.commit_sha }}"
          REVERT_CHECK=$(git log dev --grep="Revert squash merge $COMMIT" --pretty=%H -n 1)
          if [ -n "$REVERT_CHECK" ]; then
            echo "Error: Commit $COMMIT has already been reverted in dev"
            exit 1
          fi
          echo "revert_status=not_reverted" >> $GITHUB_OUTPUT

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Revert latest squash merge commit
        id: revert
        env:
          GH_TOKEN: ${{ secrets.PAT }}
        run: |
          set -x
          COMMIT="${{ steps.find_commit.outputs.commit_sha }}"
          FEATURE="${{ steps.normalize.outputs.normalized_branch }}"
          SHORT_HASH=$(echo "$COMMIT" | cut -c1-7)
          TIMESTAMP=$(date +%s)
          BRANCH="revert-conflict/$FEATURE/$SHORT_HASH-$TIMESTAMP"
          RESOLUTION="${{ github.event.inputs.conflict_resolution }}"

          echo "Attempting to revert $COMMIT from $FEATURE with resolution strategy: $RESOLUTION..."

          set +e
          git revert "$COMMIT" --no-edit
          STATUS=$?
          set -e

          if [ $STATUS -ne 0 ]; then
            echo "Conflict detected for $COMMIT"
            echo "Staging conflicted files..."

            # Handle modify/delete and other conflicts
            CONFLICTED_FILES=$(git diff --name-only --diff-filter=U || echo "")
            if [ -n "$CONFLICTED_FILES" ]; then
              for FILE in $CONFLICTED_FILES; do
                if [ "$RESOLUTION" = "delete" ]; then
                  echo "Staging deleted file: $FILE"
                  git rm "$FILE"
                else
                  if [ -f "$FILE" ]; then
                    echo "Staging modified file: $FILE"
                    git add "$FILE"
                  else
                    echo "Staging deleted file: $FILE"
                    git rm "$FILE"
                  fi
                fi
              done
            else
              echo "No conflicted files found, checking unmerged paths..."
              git status --porcelain | grep '^U' | awk '{print $2}' | while read -r FILE; do
                if [ "$RESOLUTION" = "delete" ]; then
                  echo "Staging deleted unmerged file: $FILE"
                  git rm "$FILE"
                else
                  if [ -f "$FILE" ]; then
                    echo "Staging unmerged file: $FILE"
                    git add "$FILE"
                  else
                    echo "Staging deleted unmerged file: $FILE"
                    git rm "$FILE"
                  fi
                fi
              done
            fi

            # Continue the revert, allowing empty commit if no changes
            if ! git revert --continue --allow-empty; then
              echo "Error: Failed to continue revert after staging conflicts"
              git status
              exit 1
            fi

            echo "Pushing conflicted branch $BRANCH..."
            if ! git push origin "$BRANCH"; then
              echo "Error: Failed to push branch $BRANCH"
              exit 1
            fi

            echo "Creating PR for manual conflict resolution..."
            CONFLICTED_FILES=$(git diff --name-only --diff-filter=U || echo "Unknown")
            if [ -n "$CONFLICTED_FILES" ]; then
              PR_BODY="Automatic PR: Conflicts occurred while reverting $COMMIT from branch '$FEATURE'.

              **Steps to resolve:**
              1. Open the 'Files changed' tab in this PR to view conflicts.
              2. Edit files to resolve conflict markers (<<<<<<<, =======, >>>>>>>) or confirm deletion.
              3. Commit changes directly in GitHub or locally.
              4. Merge the PR once conflicts are resolved.

              **Conflicted files:**
              \`\`\`
              $CONFLICTED_FILES
              \`\`\`

              **Resolution applied:**
              - Strategy: $RESOLUTION
              - Commit SHA: $COMMIT
              - Feature branch: $FEATURE"
            else
              PR_BODY="Automatic PR: Conflicts occurred while reverting $COMMIT from branch '$FEATURE'.

              **Steps to resolve:**
              1. Review the staged resolution (e.g., $RESOLUTION applied for files) in the 'Files changed' tab.
              2. If the resolution is incorrect, edit files or remove them as needed.
              3. Commit changes directly in GitHub or locally.
              4. Merge the PR once the resolution is confirmed.

              **Resolution applied:**
              - Strategy: $RESOLUTION
              - Commit SHA: $COMMIT
              - Feature branch: $FEATURE"
            fi

            if ! gh pr create \
              --base dev \
              --head "$BRANCH" \
              --title "Resolve conflicts: Revert $COMMIT from $FEATURE" \
              --body "$PR_BODY"; then
              echo "Error: Failed to create PR"
              exit 1
            fi

            echo "conflict=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Revert successful, committing changes..."
          git commit -m "Revert squash merge $COMMIT from $FEATURE"
          echo "conflict=false" >> $GITHUB_OUTPUT

      - name: Push revert to dev
        if: steps.revert.outputs.conflict == 'false'
        run: |
          git pull origin dev --rebase
          if ! git push origin dev; then
            echo "Error: Failed to push revert to dev"
            exit 1
          fi